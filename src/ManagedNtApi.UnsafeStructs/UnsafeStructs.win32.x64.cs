// Generated by StructFlattener v. 0.1.0
// Based on UnsafeStructs.win32.in.cs
// Commandline: "..\..\tools\StructFlattener\bin\Debug\StructFlattener.exe" UnsafeStructs.win32.in.cs -64 -out UnsafeStructs.win32.x64.cs  UnsafeStructs.in.cs
// CHANGES TO THIS FILE WILL BE LOST. Modify the input file, or improve StructFlattener if necessary. 
#if X64
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.InteropServices;
/* Unsafe structs belonging to the win32 subsystem. Generally everything here is
 * completely undocumented. The ReactOS source is a good place to look, and we
 * will generally use the same names as ReactOS for things not in the symbol 
 * files. */namespace ManagedNtApi.Unsafe
{
	//The Win32ThreadInfo / W32THREAD
	//http://blog.csdn.net/coffeemay/article/details/1238777
	//http://www.reactos.org/wiki/Techwiki:Win32k/THREADINFO
	[StructLayout ((LayoutKind)2, Pack = 1, Size = 364)]
	public unsafe struct THREADINFO
	{
		private const int WH_MIN = -1;
		private const int WH_MAX = 14;
		//TODO: When is this valid from? NT 4.0 had 12, 3.5 had 11
		public const int CWINHOOKS = WH_MAX - WH_MIN + 1;
		//[AnonymousStruct]
		//***************************************** begin: USER specific fields
		/*PTL*/[FieldOffset (0)]
		public IntPtr ptl;
		// Listhead for thread lock list
		/*PPROCESSINFO*/[FieldOffset (8)]
		public IntPtr ppi;
		// process info struct for this thread
		/*PQ*/[FieldOffset (16)]
		public IntPtr pq;
		// keyboard and mouse input queue
		/*PKL*/[FieldOffset (24)]
		public IntPtr spklActive;
		// active keyboard layout for this thread
		/*PCLIENTTHREADINFO*/[FieldOffset (32)]
		public IntPtr pcti;
		// Info that must be visible from client
		/*PDESKTOP*/[FieldOffset (40)]
		public IntPtr rpdesk;
		/*PDESKTOPINFO*/[FieldOffset (48)]
		public IntPtr pDeskInfo;
		// Desktop info visible to client
		/*PCLIENTINFO*/[FieldOffset (56)]
		public IntPtr pClientInfo;
		// Client info stored in TEB
		[FieldOffset (64)]
		public int TIF_flags;
		// TIF_ flags go here.
		[FieldOffset (72)]
		public UNICODE_STRING* pstrAppName;
		// Application module name.
		[FieldOffset (80)]
		public SMS* psmsSent;
		// Most recent SMS this thread has sent
		[FieldOffset (88)]
		public SMS* psmsCurrent;
		// Received SMS this thread is currently processing
		[FieldOffset (96)]
		public SMS* psmsReceiveList;
		// SMSs to be processed
		[FieldOffset (104)]
		public int timeLast;
		// Time, position, and ID of last message
		[FieldOffset (112)]
		public UIntPtr idLast;
		[FieldOffset (120)]
		public int cQuit;
		[FieldOffset (124)]
		public int exitCode;
		/*HDESK*/[FieldOffset (128)]
		public IntPtr hdesk;
		// Desktop handle
		[FieldOffset (136)]
		public int cPaintsReady;
		[FieldOffset (140)]
		public uint cTimersReady;
		/*PMENUSTATE*/[FieldOffset (144)]
		public IntPtr pMenuState;
		[StructLayout (LayoutKind.Explicit)]
		private struct TdbOrInSta
		{
			[FieldOffset (0)]
			public IntPtr /*PTDB*/ptdb;
			// Win16Task Schedule data for WOW thread
			[FieldOffset (0)]
			public IntPtr /*PWINDOWSTATION*/pwinsta;
			// Window station for SYSTEM thread
		};

		[FieldOffset (152)]
		public IntPtr /*PTDB*/ptdb;
		[FieldOffset (152)]
		public IntPtr /*PWINDOWSTATION*/pwinsta;
		/*PSVR_INSTANCE_INFO*/[FieldOffset (160)]
		public IntPtr psiiList;
		// thread DDEML instance list
		[FieldOffset (168)]
		public int dwExpWinVer;
		[FieldOffset (172)]
		public int dwCompatFlags;
		// The Win 3.1 Compat flags
		[FieldOffset (176)]
		public int dwCompatFlags2;
		// new DWORD to extend compat flags for NT5+ features
		/*PQ*/[FieldOffset (184)]
		public IntPtr pqAttach;
		// calculation variabled used in
		// zzzAttachThreadInput()
		[FieldOffset (192)]
		public THREADINFO* ptiSibling;
		// pointer to sibling thread info
		/*PMOVESIZEDATA*/[FieldOffset (200)]
		public IntPtr pmsd;
		[FieldOffset (208)]
		public int fsHooks;
		// WHF_ Flags for which hooks are installed
		/*PHOOK*/[FieldOffset (216)]
		public IntPtr sphkCurrent;
		// Hook this thread is currently processing
		/*PSBTRACK*/[FieldOffset (224)]
		public IntPtr pSBTrack;
		/*HANDLE*/[FieldOffset (232)]
		public IntPtr hEventQueueClient;
		/*PKEVENT*/[FieldOffset (240)]
		public IntPtr pEventQueueServer;
		[FieldOffset (248)]
		public LIST_ENTRY* PtiLink_Flink;
		public unsafe LIST_ENTRY* PtiLink_Ref {
			get {
				fixed (THREADINFO* __s = &this)
					return (LIST_ENTRY*)&__s->PtiLink_Flink;
			}
		}
		[FieldOffset (256)]
		public LIST_ENTRY* PtiLink_Blink;
		// Link to other threads on desktop
		[FieldOffset (264)]
		public int iCursorLevel;
		// keep track of each thread's level
		[FieldOffset (268)]
		public int ptLast_x;
		public unsafe POINT* ptLast_Ref {
			get {
				fixed (THREADINFO* __s = &this)
					return (POINT*)&__s->ptLast_x;
			}
		}
		[FieldOffset (272)]
		public int ptLast_y;
		/*PWND*/[FieldOffset (280)]
		public IntPtr spwndDefaultIme;
		// Default IME Window for this thread
		/*PIMC*/[FieldOffset (288)]
		public IntPtr spDefaultImc;
		// Default input context for this thread
		/*HKL*/[FieldOffset (296)]
		public IntPtr hklPrev;
		// Previous active keyboard layout
		[FieldOffset (304)]
		public int cEnterCount;
		/*PQMSG*/[FieldOffset (312)]
		IntPtr mlPost_pqmsgRead;
		public unsafe MLIST* mlPost_Ref {
			get {
				fixed (THREADINFO* __s = &this)
					return (MLIST*)&__s->mlPost_pqmsgRead;
			}
		}
		/*PQMSG*/[FieldOffset (320)]
		IntPtr mlPost_pqmsgWriteLast;
		[FieldOffset (328)]
		int mlPost_cMsgs;
		// posted message list.
		[FieldOffset (332)]
		public ushort fsChangeBitsRemoved;
		// Bits removed during PeekMessage
		[FieldOffset (334)]
		public char wchInjected;
		// character from last VK_PACKET
		[FieldOffset (336)]
		public int fsReserveKeys;
		// Keys that must be sent to the active
		// active console window.
		[FieldOffset (344)]
		public IntPtr/*PKEVENT*/* apEvent;
		// Wait array for xxxPollAndWaitForSingleObject
		/*ACCESS_MASK*/[FieldOffset (352)]
		public int amdesk;
		// Granted desktop access
		[FieldOffset (356)]
		public uint cWindows;
		// Number of windows owned by this thread
		[FieldOffset (360)]
		public uint cVisWindows;
		// Number of visible windows on this thread
		//CWINHOOKS is windows version dependent
		//public IntPtr /*PHOOK*/             aphkStart[CWINHOOKS];   // Hooks registered for this thread
		//public CLIENTTHREADINFO             cti;              // Use this when no desktop is available
	}
	//http://www.reactos.org/wiki/Techwiki:Win32k/QUEUE
	public unsafe struct MLIST
	{
		IntPtr /*PQMSG*/pqmsgRead;
		IntPtr /*PQMSG*/pqmsgWriteLast;
		int cMsgs;
	}
	//http://mista.nu/blog/2011/02/11/thread-desynchronization-issues-in-windows-message-handling/
	//http://www.reactos.org/wiki/Techwiki:Win32k/SMS
	//Win2k
	// 000
	// 004
	// 008
	// 00c
	// 010
	// 014
	// 018
	// 01c
	// 020
	// 024
	// 028
	// 02c
	// 030
	// 034
	// 038
	[StructLayout ((LayoutKind)2, Pack = 1, Size = 112)]
	public unsafe struct SMS
	{
		[FieldOffset (0)]
		public SMS* psmsNext;
		[FieldOffset (8)]
		public SMS* psmsReceiveNext;
		[FieldOffset (16)]
		public int tSent;
		[FieldOffset (24)]
		public THREADINFO* ptiSender;
		[FieldOffset (32)]
		public THREADINFO* ptiReceiver;
		/*SENDASYNCPROC*/[FieldOffset (40)]
		IntPtr lpResultCallBack;
		[FieldOffset (48)]
		public int dwData;
		[FieldOffset (56)]
		public THREADINFO* ptiCallBackSender;
		[FieldOffset (64)]
		public int lRet;
		[FieldOffset (68)]
		public int flags;
		[FieldOffset (72)]
		public IntPtr wParam;
		[FieldOffset (80)]
		public IntPtr lParam;
		[FieldOffset (88)]
		public uint message;
		/*PWND*/[FieldOffset (96)]
		public IntPtr spwnd;
		[FieldOffset (104)]
		public IntPtr pvCapture;
	}
}

#endif
